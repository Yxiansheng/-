# HTTP 的连接管理

## 短连接

HTTP 最早期的模型，也是 HTTP/1.0 的默认模型，是短连接。每一个 HTTP 请求都由它自己独立的连接完成；这意味着发起每一个 HTTP 请求之前都会有一次 TCP 握手，而且是连续不断的。

当前我们基本使用的都是 HTTP1.1，只有强制设置 Connection 为 close 才会使用短连接模型

## 长连接

长连接是 HTTP1.1 默认的连接模型，它在每一次 http 请求结束后并不会立即中断 TCP 连接，以提高下一次的 HTTP 请求速度。该连接在空闲一段时间后会被关闭(服务器可以使用 Keep-Alive 协议头来指定一个最小的连接保持时间，Keep-Alive: timeout=20)。

就算是在空闲状态，长连接还是会消耗服务器资源，而且在重负载时，还有可能遭受 DoS attacks 攻击。这种场景下，可以使用非长连接，即尽快关闭那些空闲的连接，也能对性能有所提升。

关闭长连接需要在请求头中设置 Connection 为 close

- 劣势：后一个请求需要等待前一个请求的处理响应才可进行，假如前一个请求响应速度过慢，就会造成后一个请求的阻塞

## 管道化

默认情况下，HTTP 请求是按顺序发出的。下一个请求只有在当前请求收到应答过后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。

流水线是在同一条长连接上发出连续的请求，而不用等待应答返回。这样可以避免连接延迟。理论上讲，性能还会因为两个 HTTP 请求有可能被打包到一个 TCP 消息包中而得到提升。就算 HTTP 请求不断的继续，尺寸会增加，但设置 TCP 的 MSS(Maximum Segment Size) 选项，仍然足够包含一系列简单的请求。

并不是所有类型的 HTTP 请求都能用到流水线：只有 idempotent 方式，比如 GET、HEAD、PUT 和 DELETE 能够被安全的重试：如果有故障发生时，流水线的内容要能被轻易的重试。

所有遵循 HTTP/1.1 的代理和服务器都应该支持流水线，虽然实际情况中还是有很多限制：一个很重要的原因是，目前没有现代浏览器默认启用这个特性。

- 劣势：管道化连接模型虽然请求可以并发发出，但是响应还是需要按照请求顺序来接受了，这就导致后一个响应需要等待前一个响应完毕才可进行，造成阻塞。

## 多路复用

多路复用是 HTTP2.0 提出的连接模型，可以提高了传输的效率。

特点

1. 所有的 HTTP2.0 通信都在一个 TCP 连接上完成，这个连接可以承载任意数量的双向数据流。
2. 每个数据流以消息的形式发送，而消息由一或多个帧组成。这些帧可以乱序发送，然后再根据每个帧头部的流标识符（stream id）重新组装
3. HTTP2.0 里每个数据流都可以设置优先级和依赖，优先级高的数据流会被服务器优先处理和返回给客户端，数据流还可以依赖其他的子数据流。
